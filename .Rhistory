}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
for (i in 1:4){
for (j in 1:3){
w[j] <- w[j]+0.01*new_input[i,j]*tkf[i]
}
cat('\n row:', i, w)
}
step <- function(x){ifelse(x>0, 1, 0)}
step(-0.1)
step(1.4)
x <- seq(-5, 5, 0.01)
x
plot(x, step(x), col='blue', type='o')
sigmoid <- function(x){1/(1+exp(-x))}
sigmoid <- function(x){1 / (1+exp(-x))}
sigmoid(3)
x <- seq(-5, 5, 0.01)
plot(x, sigmoid(x), col='blue')
plot(x, sigmoid(x), col='blue')
setwd("/Users/macbook/Documents/itwill/R")
setwd("/Users/macbook/Documents/itwill/R")
concrete <- read.csv("concrete.csv")
str(concrete)
normalize <- function(x) {
return((x - min(x)) / (max(x) - min(x)))
}
install.packages("neuralnet")
library(neuralnet)
concrete_train <- concrete_norm[1:773, ]
concrete_test <- concrete_norm[774:1030, ]
setwd("/Users/macbook/Documents/itwill/R")
build <- read.csv("building.csv" , header = T)
build <- read.csv("building.csv" , header = TRUE, fileEncoding = "CP949", encoding = "UTF-8")
nrow(build)
build[is.na(build)] <- 0
build
build[1]
build <- build[-1]
build
library(arules)
trans <- as.matrix(build , "Transaction")
trnas
trans
rules1 <- apriori(trans , parameter = list(supp=0.2 , conf = 0.6 , target = "rules"))
rules1
inspect(sort(rules1))
View(inspect(sort(rules1)))
#여러 규칙들중에서 보습학원 부분만 따로 검색했을때(신뢰도가 0.7이상)
rules2 <- subset(rules1 , subset = lhs %pin% '보습학원' & confidence > 0.7)
inspect(sort(rules2))
#여러 규칙들중에서 편의점 부분만 따로 검색했을때(신뢰도가 0.7이상)
rules3 <- subset(rules1 , subset = rhs %pin% '편의점' & confidence > 0.7)
rules3
inspect(sort(rules3))
#visualization
b2 <- t(as.matrix(build)) %*% as.matrix(build)
library(sna)
library(rgl)
b2.w <- b2 - diag(diag(b2))
gplot(b2.w , displaylabel=T , vertex.cex=sqrt(diag(b2)) , vertex.col = "green" , edge.col="blue" , boxed.labels=F , arrowhead.cex = .3 , label.pos = 3 , edge.lwd = b2.w*2)
par(family="AppleGothic")
gplot(b2.w , displaylabel=T , vertex.cex=sqrt(diag(b2)) , vertex.col = "green" , edge.col="blue" , boxed.labels=F , arrowhead.cex = .3 , label.pos = 3 , edge.lwd = b2.w*2)
setwd("/Users/macbook/Documents/itwill/R")
paper <- read.csv("paper1.csv" , header = TRUE, fileEncoding = "CP949", encoding = "UTF-8")
nrow(paper)
paper[is.na(paper)] <- 0
paper
rownames(paper) <- paper[,1]
paper <- paper[-1]
paper2 <- as.matrix(paper)
paper2
book_h <- read.csv("book_hour.csv" , header = TRUE, fileEncoding = "CP949", encoding = "UTF-8")
paper2
book_h
gplot(paper2 , displaylabels = T, boxed.labels = F , vertex.cex = sqrt(book_h[,2]) , vertex.col = "blue" , vertex.sides = 20 ,
edge.lwd = paper2*2 , edge.col = "green" , label.pos = 3)
par(family="AppleGothic") #그래프의 한글
gplot(paper2 , displaylabels = T, boxed.labels = F , vertex.cex = sqrt(book_h[,2]) , vertex.col = "blue" , vertex.sides = 20 ,
edge.lwd = paper2*2 , edge.col = "green" , label.pos = 3)
#visualization
library(sna)
x11()
gplot(paper2 , displaylabels = T, boxed.labels = F , vertex.cex = sqrt(book_h[,2]) , vertex.col = "blue" , vertex.sides = 20 ,
edge.lwd = paper2*2 , edge.col = "green" , label.pos = 3)
par(family="AppleGothic") #그래프의 한글
gplot(paper2 , displaylabels = T, boxed.labels = F , vertex.cex = sqrt(book_h[,2]) , vertex.col = "blue" , vertex.sides = 20 ,
edge.lwd = paper2*2 , edge.col = "green" , label.pos = 3)
gplot(paper2 , displaylabels = T, boxed.labels = F , vertex.cex = sqrt(book_h[,2]) , vertex.col = "blue" , vertex.sides = 20 ,
edge.lwd = paper2*2 , edge.col = "green" , label.pos = 3)
par(family="AppleGothic") #그래프의 한글
gplot(paper2 , displaylabels = T, boxed.labels = F , vertex.cex = sqrt(book_h[,2]) , vertex.col = "blue" , vertex.sides = 20 ,
edge.lwd = paper2*2 , edge.col = "green" , label.pos = 3)
x11()#창을 새로 하나 띄움
gplot(paper2 , displaylabels = T, boxed.labels = F , vertex.cex = sqrt(book_h[,2]) , vertex.col = "blue" , vertex.sides = 20 ,
edge.lwd = paper2*2 , edge.col = "green" , label.pos = 3)
x11()#창을 새로 하나 띄움
gplot(paper2 , displaylabels = T, boxed.labels = F , vertex.cex = sqrt(book_h[,2]) , vertex.col = "blue" , vertex.sides = 20 ,
edge.lwd = paper2*2 , edge.col = "green" , label.pos = 3)
paper2
book_h
View(book_h)
subset(book_h , name='광희')
subset(book_h , name="광희")
subset(book_h , name == "광희")
rules <- apriori(paper2,
parameter=list(support=0.2, confidence=0.6))
rules <- apriori(paper1,
parameter=list(support=0.2, confidence=0.6))
rules <- apriori(book_h,
parameter=list(support=0.2, confidence=0.6))
rules <- apriori(paper2,
parameter=list(support=0.001, confidence=0.8))
rules1 <- apriori(paper2, parameter=list(support=0.001,
confidence=0.8, targets="rules"))
trans <- as.matrix(paper , "Transaction")
trans
rules1 <- apriori(paper, parameter=list(support=0.001,
confidence=0.8, targets="rules"))
rules1 <- apriori(paper, parameter=list(support=0.2,
confidence=0.6, targets="rules"))
library(arules)
rules1 <- apriori(paper, parameter=list(support=0.2,
confidence=0.6, targets="rules"))
rules1
View(rules1)
rules4 <- apriori(paper, parameter=list(support=0.2,
confidence=0.6, targets="rules"))
View(rules4)
rules4
subset(book_h , name == "광희")
library(factoextra)
install.packages("factoextra")
library(factoextra)
zoo <- read.csv("zoo.csv", header=T)
setwd("/Users/macbook/Documents/itwill/R")
zoo <- read.csv("zoo.csv", header=T)
str(zoo)
nrow(zoo)
c <- c(10,9,1,4,10,1,7,10,3,10,1,1,6,7)
row <- c("APPLE","BACON","BANANA","CARROT","SAL","CHEESE","TOMATO")
col <- c("X","Y")
data <- matrix( c, nrow= 7, ncol=2, byrow=TRUE, dimnames=list(row,col))
data
plot(data)
plot(data)
library(stats)
km <- kmeans(data,  3) #3으로 군집화해서 시각화한다
km
cbind(data, km$cluster)
plot(round(km$center), col=km$center, pch=22,  bg=km$center, xlim=range(0:10),ylim=range(0:10))
par(new=T)  # 그래프 겹치기
plot( data, col=km$cluster+1, xlim=range(0:10), ylim=range(0:10), pch=22, bg=km$cluster+1 )
library(factoextra)
km <- kmeans(data,3)
fviz_cluster( km, data = data, stand=F)
library(factoextra)
km <- kmeans(data,3)
fviz_cluster( km, data = data, stand=F)
plot(data)
plot(data)
wisc <- read.csv("wisc_bc_data.csv)", header=T)
setwd("/Users/macbook/Documents/itwill/R")
wisc <- read.csv("wisc_bc_data.csv)", header=T)
setwd("/Users/macbook/Documents/itwill/R")
wbcd <- read.csv("wisc_bc_data.csv", header=T, stringsAsFactors=FALSE)
str(wbcd)
plot(wbcd)
plot(wbcd)
#visualization
library(stats)
km <- kmeans(wbcd,  2) #3으로 군집화해서 시각화한다
wbcd[is.na(wbcd)] <- 0
#visualization
library(stats)
km <- kmeans(wbcd,  2) #3으로 군집화해서 시각화한다
km
cbind(wbcd, km$cluster)
#plot(wbcd)
head(wbcd)
ncol(wbcd)
library(factoextra)
wbcd <-wbcd[,3:32]
wbcd2 <-wbcd[,3:32]
wbcd <- read.csv("wisc_bc_data.csv", header=T, stringsAsFactors=FALSE)
ncol(wbcd)
wbcd2 <-wbcd[,3:32]
wbcd2
wbcd2 <-wbcd[ ,3:32]
wbcd2
setwd("/Users/macbook/Documents/itwill/R")
wbcd <- read.csv("wisc_bc_data.csv", header=T, stringsAsFactors=FALSE)
#str(wbcd)
#plot(wbcd)
head(wbcd)
ncol(wbcd)
wbcd2 <- wbcd[ , 3:32]
km <- kmeans(wbcd2,  2)
km
cbind(wisc$diagnosis, km$cluster)
library(factoextra)
km <- kmeans(wbcd2, 2)
fviz_cluster( km, data = wbcd2, stand=F)
setwd("/Users/macbook/Documents/itwill/R")
wbcd <- read.csv("wisc_bc_data.csv", header=T, stringsAsFactors=FALSE)
#str(wbcd)
#plot(wbcd)
head(wbcd)
ncol(wbcd)
wbcd2 <- wbcd[ , 3:32]
km <- kmeans(wbcd2,  2)
km
cbind(wbcd$diagnosis, km$cluster)
library(factoextra)
km <- kmeans(wbcd2, 2)
fviz_cluster( km, data = wbcd2, stand=F)
fviz_cluster( km, data = wbcd2, stand=F)
#준혁이가 만든 정답과 비교하는 코드:
wisc <- read.csv("wisc_bc_data.csv")
wisc$diagnosis <- factor(wisc$diagnosis,
level=c("B","M"),
labels = c(1,2))
#View(wisc)
wisc_km <- wisc[,c(-1,-2)]
#View(wisc_km)
km <- kmeans(wisc_km, 2)
cbind(wisc$diagnosis, km$cluster)
fviz_cluster(km, data = wisc_km)
library(gmodels)
CrossTable(wisc$diagnosis, km$cluster)
#str(wbcd)
#plot(wbcd)
head(wbcd)
setwd("/Users/macbook/Documents/itwill/R")
academy <- read.csv("academy.csv")
wbcd <- read.csv("wisc_bc_data.csv", header=T,
academy <- read.csv("academy.csv", header = TRUE, fileEncoding = "CP949", encoding = "UTF-8"))
setwd("/Users/macbook/Documents/itwill/R")
academy <- read.csv("academy.csv", header = TRUE, fileEncoding = "CP949", encoding = "UTF-8"))
academy <- read.csv("academy.csv", header = TRUE, fileEncoding = "CP949", encoding = "UTF-8")
academy <- academy[  ,  c(3,4) ]
View(academy)
#k 값을 4로 주고 비지도학습 시켜 모델을 생성
km <- kmeans( academy,  4)
km
#시각화
library(factoextra)
fviz_cluster(km , data=academy,  stand=F)
par(family="AppleGothic")
fviz_cluster(km , data=academy,  stand=F)
academy_seg <- cbind(academy[ , c(1,3,4)], km$cluster)
#특정집단만 추출
academy_seg <- cbind(academy[ , c(1,3,4)], km$cluster)
academy_seg[km$cluster==1, 1] #학생번호
ave?
ave?
;
ave()
?ave
1:3
ave(1:3)
ave(1:10)
setwd("/Users/macbook/Documents/itwill/R")
emp <- read.csv("emp.csv", header = TRUE, fileEncoding = "CP949", encoding = "UTF-8")
emp
aggregate(sal~deptno, emp, mean)
emp <- read.csv("emp.csv", header = TRUE)
emp
aggregate(sal~deptno, emp, mean)
ave(emp$sal)
ave(emp$sal, emp$deptno)
emp$avgsal <- ave(emp$sal, emp$deptno)#파생변수를 하나 만듭니다.
emp
emp[ , c("ename","sal","deptno","avgsal")]
emp$avgsal <- ave(emp$sal, emp$deptno, FUN = function(x), mean(x))#파생변수를 하나 만듭니다.
emp$avgsal <- ave(emp$sal, emp$deptno, FUN = function(x) mean(x))#파생변수를 하나 만듭니다.
emp
colSums(is.na(emp))
emp$comm[is.na(emp$comm)] <- ave(emp$sal, emp$deptno, FUN = function(x) mean(x))
emp$avgsal <- ave(emp$sal, emp$deptno, FUN = function(x) mean(x))#파생변수를 하나 만듭니다.
emp
emp$avgsal <- ave(emp$sal, emp$deptno, FUN = function(x) min(x))#파생변수를 하나 만듭니다.
emp
emp$avgsal <- ave(emp$sal, emp$deptno, FUN = function(x) max(x))#파생변수를 하나 만듭니다.
emp
emp$avgsal <- ave(emp$sal, emp$deptno, FUN = function(x) mean(x))#파생변수를 하나 만듭니다.
emp
emp$comm[is.na(emp$comm)] <- ave(emp$sal, emp$deptno, FUN = function(x) mean(x))
emp
teens <-  read.csv("snsdata.csv")
table(teens$gender)
#SNS
setwd("/Users/macbook/Documents/itwill/R")
teens <-  read.csv("snsdata.csv")
table(teens$gender)
nrow(teens)
prop.table(table(teens$gender))
table(teens$gender, useNA="ifany")
teens$age <- ifelse(teens$age>=13 & teens$age <20, teens$age, NA)
colSums(is.na(teens))
#파생변수를 female로 생성한다
teens$female <- ifelse(teens$gender=="F" & !is.na(teens$gender),  1, 0)
#no_gender 파생변수를 생성한다(성별이 없는 사람들을 위해서)
teens$no_gender <- ifelse(is.na(teens$gender),1,0)
#기존 성별데이터에 NA값이 몇 개 있는지 확인
table(teens$gender, useNA="ifany")
#여성이면 1, 아니면 0
table(teens$female, useNA="ifany")
#no_gender이면 1, 아니면 0
table(teens$no_gender, useNA="ifany")
ave_age <- ave(teens$age, teens$gradyear,   FUN=function(x) mean(x, na.rm=TRUE) )
teens$age <- ifelse( is.na(teens$age), ave_age, teens$age)
aggregate(age~gradyear, data=teens, mean, na.rm=TRUE) #결측치를제거하면서 평균을 구해라
colSums(is.na(teens))
interests <- teens[5:40]
interests_z <- as.data.frame(lapply(interests, scale))
set.seed(2345)
teen_clusters <- kmeans(interests_z, 5)
teen_clusters
teen_clusters$size
teen_clusters$centers
teen_clusters$cluster
teen_clusters
teen_clusters$size
result = cbind( data.frame(teens$female, teen_clusters$cluster ) )
attach(result)
tapply( teens.female, teen_clusters.cluster, sum, na.rm=TRUE )
h <- c(165,180)
w <- c(50,65)
d <- data.frame(키=h, 몸무게=w)
sum(abs(d[1,]-d[2,]))
res <- cbind(teens, teen_clusters$cluster)
attach(res)
tapply(female, teen_clusters$cluster, sum)
tapply(female, teen_clusters$cluster, sum, mean)
tapply(female, teen_clusters$cluster, max)
tapply(female, teen_clusters$cluster, ave)
tapply(female, teen_clusters$cluster, sum)
tapply(female, teen_clusters$cluster, max)
tapply(female, teen_clusters$cluster, sum)
teens$group <- teen_clusters$cluster
result1 <- teens[teens$female==1,]
table(result1$group)
res
head(res)
x<-cbind(teens$female, teen_clusters$cluster)
head(x)
tapply(x[,1], x[,2], sum)
#각 군집별로 female(여성)이 몇 명인지 출력
teens$female
#각 군집별로 female(여성)이 몇 명인지 출력
head(teens$female)
head(x)
head(teen_clusters$cluster)
tapply(teens$gender=="F",teen_clusters$cluster, table)
#각 군집별로 female(여성)이 몇 명인지 출력
res1 <- cbind( teens$female, teen_clusters$cluster)
colnames(res1) <- c("female", "clusterNum")
res <- as.data.frame(res1)
tapply( res1$female, res1$clusterNum, sum)
tapply( res1$female, res1$cluster, sum)
colnames(res1)
tapply( res1$female, res1$clusterNum, sum)
res1
head(res1)
head(x)
tapply(female, clusterNum, sum)
tapply(female[,1], clusterNum[,2], sum)
tapply(res1[,1], res1[,2], sum)
tapply(res1$female, res1$clusterNum, sum)
#각 군집별로 female(여성)이 몇 명인지 출력
tapply(teens$gender=="F",teen_clusters$cluster, length)
#각 군집별로 female(여성)이 몇 명인지 출력
tapply(teens$gender=="F",teen_clusters$cluster, table)
tapply(teens$gender,teen_clusters$cluster, table)
#각 군집별로 female(여성)이 몇 명인지 출력
tapply(teens$gender=="F",teen_clusters$cluster, length)
#각 군집별로 female(여성)이 몇 명인지 출력
tapply(teens$gender=="F",teen_clusters$cluster, sum)
